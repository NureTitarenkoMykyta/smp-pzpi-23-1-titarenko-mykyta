 
 
Міністерство освіти і науки України 
 
 
 
Харківський національний університет радіоелектроніки 
 
 
 
 
 
 
 
Кафедра програмної інженерії 
 
 
 



 
Звіт з лабораторної роботи №1
з дисципліни «Скриптові мови програмування» 
 
 
 
 
 






 
Виконав:                                                                              Перевірили: 
гр.ПЗПІ-23-1                                                                       Сокорчук Ігор 
Тітаренко Микита                                                              Петрович 
 
 
 


Харків 2025 
ЗАВДАННЯ 
 
Розробити Bash-скрипт, який обробляє експортований із сайту https://cist.nure.ua/ розклад занять для всіх груп потоку в форматі CSV та перетворює його у формат CSV для завантаження в Google Календар https://support.google.com/.
 
ХІД РОБОТИ
 
1.	Створення функції format_file
1.1.	Використання iconv для перетворення кодування файлу з Windows-1251 в UTF-8 для коректної подальшої обробки.
1.2.	Заміна \r на \n за допомгою sed, бо саме формат файлу LF потрібен для Unix-подібних систем. 
Фрагмент коду в якому реалізована функція format_file: 
1.	format_file(){
2.	        iconv -f WINDOWS-1251 -t UTF-8 "$timetable" > "$result"
3.	        sed -i 's/\r/\n/g' "$result"
4.	}
2.	Реалізація функції  create_groups для створення файлу groups.csv
2.1.	Використання регулярного виразу задля знаходження назви групи (йде до першого пробілу). Використання 1d у виразі, щоб уникнути перший рядок (видалити).
2.2.	Перевірка чи є в першому рядку символ `-`. Якщо немає, то повертати 1 (у файлах, де тільки 1 група, немає назви групи, тому перше слово буде назва дисципліни, яка не містить в собі тире).
2.3.	Сортування файлу за допомогою sort (вказуючи роздільник `-` і сортуючи тільки за 3 колонкою -k3,3n, бо це і є номер групи). Використання uniq задля прибрання повторів груп.
Фрагмент коду в якому реалізована функція create_groups: 
1.	create_groups(){
2.	
3.	        sed '1d; s/^\"[[:space:]]*\([^ ]*\).*$/\1/' "$result" > groups.csv
4.	        if [[ ! $(head -n 1 groups.csv) =~ "-" ]]; then
5.	                return 1
6.	        fi
7.	        sort -t'-' -k3,3n "groups.csv" | uniq > temp.csv && mv temp.csv "groups.csv"
8.	        return 0
9.	}
3.	Реалізація функції select_timetable для обрання наявного .csv файлу з поточної директорії 
3.1.	Виведення всіх наявних файлів розширення .csv, які підходять шаблону, за допомогою ls. 
3.2.	Сортування списку, розділивши його за символом `_` і сортуючи спочатку за 4 колонкою, потім 3, потім 2 (рік, місяць, день). 
3.3.	Використання select для надання можливості користувачу обрати потрібний файл. 
3.4.	Призначення змінній обраного варіанту і використання break задля виходу із циклу.
3.5.	Використання функції format_file для зміни кодування і символу нового рядка в обраному файлі.
Фрагмент коду в якому реалізована функція select_timetable:
1.	select_timetable(){
2.	        select var in $(ls TimeTable_??_??_20??.csv | sort -t'_' -k4,4n -k3,3n -k2,2)
3.	        do
4.	                timetable=$var
5.	                break
6.	        done
7.	
8.	        format_file
9.	}
4.	Реалізація функції select_group для обрання групи з .csv файлу
4.1.	Виклик функції create_groups для створення файлу з переліком груп.
4.2.	Перевірка чи є у цьому файлі тільки одна група за допомогою $?, щоб перевірити код завершення останньої виконаної функції (як вже зазначалося вище, якщо в файлі тільки одна група, то функція create_groups поверне 1).
4.3.	Використання cat для виведення тексту (всіх груп) з файлу groups.csv
4.4.	Використання select для надання можливості користувачу обрати потрібну групу.
Фрагмент коду в якому реалізована функція select_group:
1.	select_group(){
2.	        create_groups
3.	
4.	        if [[ $? -eq 1 ]]; then
5.	                return 1
6.	        fi
7.	        select var in $(cat groups.csv)
8.	        do
9.	                group=$var
10.	                break
11.	        done
12.	}
5.	Реалізація функції check_existence_of_group для перевірки наявності групи в .csv файлі.
5.1.	Виклик функції create_groups для створення файлу з переліком груп.
5.2.	Перевірка чи є у цьому файлі тільки одна група за допомогою $?, щоб перевірити код завершення останньої виконаної функції (як вже зазначалося вище, якщо в файлі тільки одна група, то функція create_groups поверне 1).
5.3.	Використання утиліти grep для перевірки наявності хоча б одного рядку в файлі (використання -q, щоб не виводити результат пошуку). Якщо такий рядок є (а значить вказана користувачем група існує), то повертання успішної операції.
Фрагмент коду в якому реалізована функція check_existence_of_group:
1.	check_existence_of_group(){
2.	        create_groups
3.	
4.	        if [[ $? -eq 1 ]]; then
5.	                return 0
6.	        fi
7.	
8.	        if grep -q $group "groups.csv"; then
9.	                return 0
10.	        else
11.	                return 1
12.	        fi
13.	}
6.	Реалізація функції convert_csv_for_import_in_Google_Calendar для створення .csv файлу для завантаження у Google календар
6.1.	Використання awk для більш зручного та ефективного оброблення колонок у csv файлі. Використання опції -v для можливості передачі параметрів, опції -F для вказання роздільника,
6.2.	Виведення потрібного першого рядку для шаблону Google календаря обмежуючи блок умовою NR=1 (тобто виконувати тільки для 1 рядка).
6.3.	Використання вбудованої функції split для отримання назви групи і типу заняття. Виведення у файл за допомогою print. Отримання доступу до потрібної колонки через $.
Фрагмент коду реалізації функції convert_csv_for_import_in_Google_Calendar наведений в додатку A.
7.	Реалізація додаткових перевірок аргументів функції
7.1.	Надання довідки при використання --help,
7.2.	Вивід версіїї за допомогою --version.
7.3.	Присвоєння значення змінної quiet 1 якщо вказан ключ -q або --quiet. Якщо quiet = 1, вкінці файлу не буде виведено оброблений документ. 
ВИСНОВОК 
 
Отже, виконавши лабораторну роботу №1, я ознайомився з основними командами Bash для роботи з файлами та текстовими даними. Навчився використовувати команди select, ls, awk, sort, uniq, tee, cat, sed, iconv тощо. Розробив Bash-скрипт для перетворення CSV-файла розкладу занять у придатний для імпорту в Google Календар CSV-формат.
 
ВИКОРИСТАНІ ДЖЕРЕЛА 
 
1.	Лекція 6: Розширені можливості AWK / Матеріали лекцій з дисципліни / Скриптові мови програмування / dl.nure. URL: https://dl.nure.ua/mod/page/view.php?id=662681 (дата звернення: 23.03.2025). 
2.	Sed Command in Linux/Unix With Examples / geeksforgeeks. URL:  https://www.geeksforgeeks.org/sed-command-in-linux-unix-with-examples/ (дата звернення: 24.03.2025).

ДОДАТОК А

Реалізація функції  convert_csv_for_import_in_Google_Calendar:
1.	convert_csv_for_import_in_Google_Calendar(){
2.	awk -v group="$group" -F '\",\"' '
3.	
4.	function format_time(time){
5.	        split(time, formatted_time, ":")
6.	        if (formatted_time[1] < 12){
7.	                if (formatted_time[1] == 00){
8.	                        result_time = "12:" formatted_time[2] " AM"
9.	                } else {
10.	                        result_time = formatted_time[1] ":" formatted_time[2] " AM"
11.	                }
12.	        } else {
13.	                if (formatted_time[1] < 13){
14.	                        result_time = formatted_time[1] ":" formatted_time[2] " PM"
15.	                } else {
16.	                        result_time = formatted_time[1] - 12 ":" formatted_time[2] " PM"
17.	                }
18.	        }
19.	
20.	        return result_time
21.	}
22.	
23.	NR==1 {print "Subject,Start Date,Start Time,End Date,End Time,All Day Event,Description,Location"}
24.	NR!=1 {
25.	        split($1, arr, "[\" ]")
26.	
27.	        if (arr[2] == group || arr[3] != "-"){
28.	
29.	                split($12, description, " ")
30.	
31.	                if (description[2] == "Лб"){
32.	                        lessons[$12] += 0.5
33.	                } else {
34.	                        lessons[$12]++
35.	                }
36.	                split($2, start_date, ".")
37.	                split($4, end_date, ".")
38.	
39.	                start_time = format_time($3)
40.	                end_time = format_time($5)
41.	
42.	                print $1 "\",\"" start_date[2] "/" start_date[1] "/" start_date[3] "\",\"" start_time "\",\"" end_date[2] "/" end_date[1] "/" end_date[3]  "\",\"" end_time "\",\"FALSE\",\"" $12 ";№" int(lessons[$12] + 0.5) "\""
43.	        }
44.	}
45.	' "$result" > temp.csv && mv temp.csv "$result"
46.	
47.	}

